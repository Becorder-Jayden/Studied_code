# 그리디 알고리즘

by 나동빈님

링크 : https://www.youtube.com/watch?v=2zjoKjt97vQ



* 그리디 알고리즘(탐욕법) : **현재 상황에서 지금 당장 좋은 것만 고르는 방법**
* 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
* 풀이의 정당성 분석이 중요
  * 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토

* 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다
* 많은 코딩 테스트에서 제시되는 문제 유형 중 하나



※ 예시 문제 : [거스름 돈, 곱하기 혹은 더하기, 모험가 길드]

* 최적의 해를 빠르기 구하기 위해 **가장 큰 화폐 단위부터** 돈을 거슬러 주면 된다
* 가장 큰 화폐 단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유?
  * 가지고 있는 동전 중에서 **큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문**
* 그리디 알고리즘 문제에서는 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 한다

```python
# 거스름돈 답안 예시

n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인
array = [500, 100, 50, 10]

for coin in array:
    count += n//coin # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
    n %= coin # %= : 할당 연사자 중 하나로 왼쪽 변수에 오른쪽 값을 나눈 후 그 나머지를 왼쪽 변수에 할당
    
print(count)
```

* 화폐의 종류가 K일 때, 코드의 시간 복잡도는 **O(K)**
* 시간 복잡도는 금액과 무관하고 동전의 총 종류에만 영향을 받는다



※ 예시 문제 : [1이 될 때까지]



## 구현 : 시뮬레이션과 완전 탐색



구현 : **머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정**

* 흔히 알고리즘 대회의 구현 유형의 문제란

  풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제

* 예시

  * 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
  * 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
  * 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
  * 적절한 라이브러리를 찾아서 사용해야 하는 문제

* 일반적으로 알고리즘 문제의 2차원 공간은 **행렬**의 의미로 사용

* 시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 **방향 벡터**가 자주 활용

  cf. 방향 벡터 : 이동하는 방향과 크기를 갖는 값

​			ex) dx = [0, -1, 0, 1], dy = [1, 0, -1 ,0]



※ 예제 문제 : [상하좌우, 시각, 왕실의 나이트, 문자열 재정렬]

* 요구사항대로 충실히 구현하면 되는 문제

* 일련의 명령에 따라 개체를 차례대로 이동시키는 문제를 시뮬레이션 유형으로 분류할 수 있다 

  cf. 문제 풀이 사이트에 따라 표기가 다를 수 있으므로, 코딩 테스트에서 시뮬레이션, 구현, 완전 탐색 유형은 서로 유사한 점이 많다는 정도로 기억하자

* 가능한 경우의 수를 모두 검사해보는 탐색 방법을 **완전 탐색(Brute Forcing)** 문제 유형이라고 부른다

* 방향 벡터를 설정하여 풀이하는 아이디어

